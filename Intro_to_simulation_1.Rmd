---
title: "Introduction to simulation, Part 1"
author: "Put your name here"
date: "Put the date here"
output: pdf_document
---
<!-- Please don't mess with the next two lines! -->
\newenvironment{answer}{\definecolor{shadecolor}{RGB}{225, 225, 255}\begin{shaded}}{\end{shaded}}
<!-- Please don't mess with the previous two lines! -->


## Introduction

In this module, we'll learn about simulation and randomization. When we want to understand how sampling works, it's helpful to simulate the process of drawing samples repeatedly from a population. In the days before computing, this was very difficult to do. Now, a few simple lines of computer code can generate thousands (even millions) of random samples, often in a matter of seconds or less.


## Instructions

Presumably, you have already created a new project and downloaded this file into it. Please knit the document and work back and forth between this R Markdown file and the PDF output as you work through this module.

When you are finished with the assignment, knit to PDF one last time, proofread the PDF file **carefully**, export the PDF file to your computer, and then submit your assignment.

Sometimes you will be asked to add your own R code. That will appear in this document as a code chunk with a request for you to add your own code, like so:

```{r}
## Add code here to [do some task]...
```

Be sure to remove the line `## Add code here to [do some task]...` when you have added your own code.

Sometimes you will be asked to type up your thoughts. That will appear in the document as follows:

\begin{answer}
Please write up your answer here.
\end{answer}

Again, please be sure to remove the line "Please write up your answer here" when you have written up your answer. In these areas of the assignment, please use contextually meaningful full sentences/paragraphs (unless otherwise indicated) and proper spelling, grammar, punctuation, etc. This is not R code, but rather a free response section where you talk about your analysis and conclusions. If you need to use some R code as well, you can use inline R code inside the block between `\begin{answer}` and `\end{answer}`, or if you need an R code chunk, please go outside the `answer` block and start a new code chunk.


## Load Packages

We load the `mosaic` package.

```{r, warning = FALSE, message=FALSE}
library(mosaic)
```

One more bit of technical detail. Since there will be some randomness involved here, I will need to include an R command to ensure that we all get the same results every time this document is knit. This is called "setting the seed". Don't worry too much about what this is doing under the hood. The basic idea is that two people who start with the same seed will generate the same sequence of "random" numbers.

The seed `1234` in the command below is totally arbitrary. It could have been any number at all. If you change the seed, you will get different output in later code, so we all need to use the same seed. But the actual common value we all use for the seed is irrelevant.

```{r}
set.seed(1234)
```


## Flipping a coin

One of the simplest acts to simulate is flipping a coin. We could get an actual coin and physically flip it over and over again, but that is time-consuming and annoying. It is much easier to flip a "virtual" coin inside the computer. One way to accomplish this in R is to use the `rflip` command from the `mosaic` package.

Here is one coin flip:

```{r}
rflip(1)
```

Here are ten coin flips:

```{r}
rflip(10)
```

Just to confirm that this is a random process, let's flip ten coins again:

```{r}
rflip(10)
```

### Exercise

In ten coin flips, how many would you generally expect to come up heads? Is that the actual number of heads you saw in the simulations above? Why aren't the simulations coming up with the expected number of heads each time?

\begin{answer}
Please write up your answer here.
\end{answer}

*****


## Multiple simulations

Suppose now that you are not the only person flipping coins. Suppose everyone in the class is flipping coins. We'll start with ten coin flips per person, a task that could be reasonably done even without a computer.

You might observe three heads in ten flips. Fine, but what about everyone else in the class? What numbers of heads will they see?

The `do` command is a way of doing something multiple times. Imagine there are twenty students in the class, each flipping a coin ten times. Observe:

```{r}
do(20) * rflip(10)
```

The syntax could not be any simpler: "`do(20) *`" means, literally, "do twenty times." In other words, this command is telling R to repeat an action twenty times, where the action is flipping a single coin ten times.


You'll notice that in place of a list of outcomes (H or T) of all the individual flips, we have instead a summary of the number of heads and tails each student sees. Each row represents a student, and the columns give information about each student's flips. (There are `n = 10` flips for each student, but then the number of heads/tails---and the corresponding "proportion" of heads---changes from student to student.)

Looking at the above rows and columns, we see that the output of our little coin-flipping experiment is actually stored in a data frame! Let's give it a name and work with it.

```{r}
coin_flips_20_10 <- do(20) * rflip(10)
coin_flips_20_10
```

(Note: the results stored in `coin_flips_20_10` are not the same as the results generated the last time we ran the `do(20) * rflip(10)` command. Remember that these are randomized simulations. The randomness means that the outcome will be different each time we run the command.)

It is significant that we can store our outcomes this way. Because we have a data frame, we can apply all our data analysis tools (graphs, charts, tables, summary statistics, etc.) to the "data" generated from our simulation.

For example, what is the mean number of heads these twenty students observed?

```{r}
mean(coin_flips_20_10$heads)
```


### Your turn

Calculate the mean *proportion* of heads (rather than the mean *count*). Then explain why your answer makes sense in light of the mean count of heads calculated above.

```{r}
## Add code here to calculate the mean proportion of heads.
```

\begin{answer}
Please write up your answer here.
\end{answer}

*****

Although the variable `heads` is a numerical variable, we are going to treat it like a categorical variable for graphing purposes so that we can see a clear bar sitting over every possible number of heads.

```{r}
ggplot(coin_flips_20_10, aes(x = factor(heads))) +
    geom_bar()
```

Let's do the same thing, but now let's consider the *proportion* or percentage of heads.

```{r}
ggplot(coin_flips_20_10, aes(x = factor(prop))) +
    geom_bar()
```

## Bigger and better!

There are two obvious directions we could go to make our experiment bigger and better. One way is to recruit more students. With only twenty students, it was possible that, for example, nobody would get all heads or all tails. Indeed, in `coin_flips_20_10` there were no students who got all heads or all tails. Also, there were more students with four heads and seven heads than with five heads, even though we "expected" the average to be five heads. There is nothing particularly significant about that; it happened by pure chance alone. Another run through the above commands would generate a somewhat different outcome. That's what happens when things are random.

Instead, let's try it again with 2000 students.

```{r}
coin_flips_2000_10 <- do(2000) * rflip(10)
tail(coin_flips_2000_10)
mean(coin_flips_2000_10$heads)
ggplot(coin_flips_2000_10, aes(x = factor(heads))) +
    geom_bar()
```

This is helpful. In contrast with the simulation with twenty students, the bar chart gives us something closer to what we expect. The mode is at five heads, and every possible number of heads is represented, with decreasing counts as one moves away from five. With 2000 people flipping coins, all possible outcomes---including rare ones---are better represented.

The same chart, this time with the proportion of heads:

```{r}
ggplot(coin_flips_2000_10, aes(x = factor(prop))) +
    geom_bar()
```


### Exercise

Do you think the shape of the distribution would be appreciably different if we used 20,000 or even 200,000 students? Why or why not? (Normally, I would encourage you to test your theory by trying it in R. However, it takes a *long* time to simulate that many flips and I don't want you to tie up server resources and memory. Think through this in your head.)

\begin{answer}
Please write up your answer here.
\end{answer}

*****

The other direction of growth is to increase the number of coin flips each student performs. Let's go back to our classroom of twenty students, but now, each student will flip the coin 1000 times.

When graphing this, it won't make much sense to look at bars anymore. There are a thousand possible values (technically, 1001 values) along the x-axis. We'll use proper histograms from this point forward.

```{r}
coin_flips_20_1000 <- do(20) * rflip(1000)
tail(coin_flips_20_1000)
mean(coin_flips_20_1000$heads)
ggplot(coin_flips_20_1000, aes(x = heads)) +
    geom_histogram()
```

Okay, this is pretty useless. Given the thousand possible values of `heads`, we're only going to see the twenty that this particular small group of students manages to obtain.

So let's go really big now and use 2000 students, each of whom flips the coin 1000 times. This code chunk accounts for a substantial amount of the time it takes to knit this document.

```{r}
coin_flips_2000_1000 <- do(2000) * rflip(1000)
tail(coin_flips_2000_1000)
mean(coin_flips_2000_1000$heads)
ggplot(coin_flips_2000_1000, aes(x = heads)) +
    geom_histogram(binwidth = 10, boundary = 500)
```

Now with proportions. (Notice that we have to change the binwidth. Make sure you understand why we can't leave `binwidth = 10` like we had before.)

```{r}
ggplot(coin_flips_2000_1000, aes(x = prop)) +
    geom_histogram(binwidth = 0.01, boundary = 500)
```


### Exercise

Comment on the histogram above. Describe its shape using the vocabulary of the three important features (modes, symmetry, outliers). Why do you think it's shaped like this?

\begin{answer}
Please write up your answer here.
\end{answer}

*****

### Exercise

Given the amount of randomness involved (each students is tossing coins which randomly come up heads or tails), why do we see so much structure and orderliness in the histograms (at least the ones where we use lots of students)?

\begin{answer}
Please write up your answer here.
\end{answer}

*****

## But who cares about coin flips?

It's fair to ask why we go to all this trouble to talk about coin flips. The most pressing research questions of our day do not involve people sitting around and flipping coins, either physically or virtually.

But now substitute "heads" and "tails" with "cancer" and "no cancer". Or "guilty" and "not guilty". Or "shot" and "not shot". The fact is that many important issues are measured as variables with two possible outcomes. There is some underlying "probability" of seeing one outcome over the other. (It doesn't have to be 50% like the coin.) Statistical methods---including simulation---can say a lot about what we "expect" to see if these outcomes are truly random. More importantly, when we see outcomes that *aren't* consistent with our simulations, we may wonder if there is some underlying mechanism that may be not so random after all. It may not look like it on first blush, but this idea is at the core of the scientific method.

For example, let's suppose that 85% of U.S. adults support some form of background checks for gun buyers.^[This is likely close to the truth. See this article: http://www.people-press.org/2015/08/13/continued-bipartisan-support-for-expanded-background-checks-on-gun-sales] Now, imagine we went out and surveyed a random group of people and asked them a simple yes/no question about their support for background checks. What might we see?

Let's simulate. Imagine flipping a coin, but instead of coming up heads 50% of the time, suppose it were possible for the coin to come up heads 85% of the time.^[The idea of a "weighted" coin that can do this comes up all the time in probability and statistics courses, but it seems that it's not likely one could actually manufacture a coin that could come up heads more or less than 50% of the time when flipped. See this paper for more details: http://www.stat.columbia.edu/~gelman/research/published/diceRev2.pdf] A sequence of heads and tails with this weird coin would be much like randomly surveying people and asking them about background checks.

We can make a "virtual" weird coin with the `rflip` command by specifying how often we want heads to come up.

```{r}
rflip(100, prob = 0.85)
```

The results from the above code can be seen as a survey of 100 random U.S. adults about their support for background checks for purchasing guns. "Heads" means "supports" and "tails" means "opposes."

### Your turn

Now imagine that you and your classmates (20 students total) all go out and conduct your survey of 100 random U.S. adults. Write some R code that simulates this. Plot a histogram of the results. (Hint: you'll need the `do` function.) Use the proportion of supporters (`prop`), not the raw count of supporters (`heads`).

```{r}
## Add code here to simulate 20 surveys of 100 U.S. adults.
## Plot the results in a histogram using proportions.
```

Now do the same this with 2000 students.

```{r}
## Add code here to simulate 2000 surveys of 100 U.S. adults.
## Plot the results in a histogram using proportions.
```

Run the simulation one last time, but this time, survey 1000 adults and not just 100.

```{r}
## Add code here to simulate 2000 surveys of 1000 U.S. adults.
## Plot the results in a histogram using proportions.
```

What changed when you went from 20 students to 2000?

\begin{answer}
Please write up your answer here.
\end{answer}

What changed when you surveyed 1000 people instead of 100?

\begin{answer}
Please write up your answer here.
\end{answer}

*****

## Sampling variability

We've seen that taking repeated samples (using the `do` command) leads to lots of different outcomes. That is randomness in action. We don't expect the results of each survey to be exactly the same every time the survey is administered.

We've also seen that if we don't simulate enough times (for example, when we used the class of size 20), then we don't get a good representation of the distribution of all possible outcomes.

So let's agree from here on out that when we simulate, we will always simulate a "large" number of times. In other words, we won't use `do(20)` anymore. We'll need something like `do(2000)`. (There is some theory behind choosing the number of times we need to simulate, but we're not going to get into all that.)

Do not confuse the number of simulations with the sample size! When we were flipping coins, the sample size was each person's number of flips. When we survey, the sample size is the number of people to whom we present our questions. This number can be small or large.

### Exercise

Go back and look at all the examples above where we used `do(2000)` and plotted proportions. What do you notice about the range of values on the x-axis when the sample size is small versus large? (In other words, in what way is the histogram of proportions different when using `rflip(10)` or `rflip(100)` versus `rflip(1000)`?)

\begin{answer}
Please write up your answer here.
\end{answer}

*****


## Conclusion

Simulation is a tool for understanding what happens when a statistical process is repeated many times in a randomized way. The availability of fast computer processing makes simulation easy and accessible. The goal will eventually be to use simulation to answer important questions about data and the processes in the world that generate data. This is possible because, despite the ubiquitous presence of randomness, a certain order emerges when the number of samples is large enough. Even though there is sampling variability (different random outcomes each time we sample), there are patterns in that variability that can be exploited to make predictions.
